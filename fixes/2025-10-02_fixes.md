# Исправления от 2025-10-02

## Исправление прикрепления имени оператора в специальных заданиях

**Проблема:** В специальных заданиях не прикреплялось имя оператора (поле `operator_name`), в отличие от обычных заданий.

**Решение:** Добавлено поле `operator_name` при назначении специальных заданий в трех местах:

### Изменения:

- ✅ **`src/handlers/task_handlers/auto_special_task_handler.py` (строки 262-273)**
  - Добавлено получение ФИО из БД: `SELECT fio FROM wms_bot.t_staff WHERE id = '{staff_id}'`
  - Добавлено поле `operator_name = '{operator_full_name}'` в SQL запрос

- ✅ **`src/scheduler/task_scheduler.py` (строки 332-339)**
  - Добавлено поле `operator_name = '{opv['fio']}'` в SQL запрос
  - Используется уже загруженное ФИО из данных ОПВ

- ✅ **`src/utils/opv_utils.py` (строки 188-195)**
  - Добавлено поле `operator_name = '{opv['fio']}'` в SQL запрос
  - Используется уже загруженное ФИО из данных ОПВ

**Результат:** Теперь специальные задания прикрепляют имя оператора так же, как и обычные задания.

---

## Исправление ошибки двойного обновления таймера

**Проблема:** При завершении спец-задания таймер основного задания запускался дважды, что приводило к ошибке:
```
❌ [ERROR] Ошибка обновления таймера 64374: Message is not modified: specified new message content and reply markup are exactly the same as a current content and reply markup of the message
```

**Причина:** В функции `complete_special_task_inline` (special_tasks.py) происходил дублирующий запуск таймера:
1. Первый запуск в строках 157-159 после завершения спец-задания
2. Второй запуск в строке 177 через вызов `restore_frozen_task_if_needed`

**Решение:** Удалены строки 175-177 с дублирующим вызовом `restore_frozen_task_if_needed`, так как восстановление таймера уже происходит в блоке выше.

**Изменения:**
- ✅ **special_tasks.py (строки 175-177)** - удален дублирующий вызов восстановления таймера

---

## Реализация последовательного перетекания заданий по слотам

**Проблема:** После удаления зависимости от слотов задания стали выбираться хаотично - задания 4 слота могли попадать на 1 слот, что нарушало логическую последовательность работы.

**Решение:** Добавлена логика последовательного "перетекания" заданий по слотам: 1→2→3→4. Теперь задания из предыдущих слотов, оставшиеся в ожидании, автоматически переходят на следующие слоты.

**Логика работы:**
- **Слот 1 (8:00-10:30):** выбираются только задания `slot = 1`
- **Слот 2 (10:30-13:30):** выбираются задания `slot ≤ 2` (невыполненные из слота 1 + новые из слота 2)
- **Слот 3 (13:30-16:30):** выбираются задания `slot ≤ 3` (невыполненные из слотов 1,2 + новые из слота 3)
- **Слот 4 (16:30-20:00):** выбираются задания `slot ≤ 4` (все невыполненные + новые из слота 4)

**Изменения:**
- ✅ **task_assignment.py (строка 7)** - добавлен импорт `get_current_slot` из `time_utils`
- ✅ **task_assignment.py (строки 82-88)** - добавлено определение текущего слота и проверка рабочего времени
- ✅ **task_assignment.py (строки 90-102)** - переработан SQL запрос для выборки заданий
- ✅ **task_assignment.py (строка 121)** - упрощена выборка задания

**Результат:** 
- Задания последовательно перетекают по слотам: 1→2→3→4
- Невыполненные задания из предыдущих слотов имеют приоритет перед новыми
- Задания 4 слота больше не попадают на 1 слот
- Получение заданий доступно только в рабочее время смены

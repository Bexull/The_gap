# Исправления от 2025-10-01

## Исправление системы заморозки заданий при назначении спец-заданий

**Дата:** 01.10.2025 20:42-21:35

**Найдено несколько критических проблем:**

### Проблема 1: Уведомления о заморозке не отправлялись
При назначении спец-задания через планировщик уведомление о заморозке могло не отправиться, если таймер самостоятельно обнаруживал статус "Заморожено" и останавливался.

**Решение:**
- Разделены блоки остановки таймера и отправки уведомления
- Уведомление отправляется **ВСЕГДА**, независимо от наличия активного таймера

### Проблема 2: Не находились задания "На доработке"
Планировщик проверял `AND status IN ('Выполняется', 'На доработке') AND time_end IS NULL`, но задания "На доработке" **имеют заполненный time_end** (ЗС заполняет его при возврате).

**Решение:**
- Изменена логика SQL запроса: для "Выполняется" проверяем `time_end IS NULL`, для "На доработке" - без проверки

### Проблема 3: Не учитывался тип данных user_id (int8/bigint)
В PostgreSQL user_id хранится как bigint (int8), что могло приводить к проблемам сравнения.

**Решение:**
- Добавлен явный CAST: `user_id::bigint`

**Изменения:**
- ✅ **task_scheduler.py (строки 198-248)** - полностью переработана логика поиска и заморозки:
  - Добавлен CAST user_id::bigint для корректного сравнения
  - Изменен SQL запрос: `(status = 'Выполняется' AND time_end IS NULL) OR (status = 'На доработке')`
  - Добавлено подробное логирование для диагностики
  - Разделены блоки остановки таймера и отправки уведомления
  - Уведомление отправляется всегда, независимо от таймера

- ✅ **auto_special_task_handler.py (строки 216-267)** - аналогичные изменения для команды `/set`:
  - Добавлено подробное логирование всего процесса
  - Уведомления о заморозке отправляются всегда
  - Добавлен traceback для ошибок

**Результат:** Система заморозки теперь работает корректно для всех случаев, включая задания "На доработке". Уведомления отправляются гарантированно.

---

## Убрана зависимость от временных слотов

**Проблема:** Задания были жестко привязаны к временным слотам. Если время слота проходило, задание оставалось в БД в ожидании. Исключение было только для задания "Выкладка приход".

**Решение:** Убрана проверка временных слотов для всех заданий. Теперь распределение происходит только по сменам (дневная/ночная).

**Изменения:**
- ✅ **task_assignment.py (строка 7)** - убран импорт `get_current_slot` из `time_utils`
- ✅ **task_assignment.py (строки 77-91)** - убрана вся логика проверки слотов:
  - Убрана переменная `current_slot = get_current_slot(shift)`
  - Убран SQL запрос для проверки заданий "Выкладка приход"
  - Убрана проверка активного слота и сообщение "⏰ Сейчас не время активного слота"
- ✅ **task_assignment.py (строки 82-91)** - упрощен SQL запрос для выборки заданий:
  - Убрано условие `(task_name = 'Выкладка приход') OR (slot = {current_slot})`
  - Теперь выбираются все задания смены независимо от слота

**Результат:** 
- Сотрудники могут получать **все доступные задания** на их смену в любое время
- Нет больше ожидающих заданий из-за истечения времени слота
- Информация о слотах остается в БД для целей планирования (не влияет на работу бота)
- Разделение теперь только по сменам: дневная (8:00-20:00) и ночная (20:00-8:00)

---

## HOTFIX: Ошибки импорта в завершении спец-заданий

**Проблема 1:** При завершении спец-задания возникала ошибка "cannot access local variable 'frozen_tasks_info' where it is not associated with a value".

**Корневая причина:** Импорт `frozen_tasks_info` был внутри условного блока `if not frozen_task_df.empty:`, но переменная использовалась позже вне этого блока (при очистке данных).

**Проблема 2:** При восстановлении задания возникала ошибка "cannot access local variable 'seconds_to_hms' where it is not associated with a value".

**Корневая причина:** Импорт `seconds_to_hms` был внутри блока `if task_id in frozen_tasks_info:`, но функция использовалась позже вне этого условия (в логах).

**Исправления:**
- ✅ **special_task_completion.py (строка 23)** - перенесен импорт `frozen_tasks_info` в начало функции `complete_special_task_directly()`
- ✅ **special_task_completion.py (строка 89)** - перенесен импорт `seconds_to_hms` и `align_seconds` в начало блока try
- ✅ Удалены дублирующие импорты из условных блоков

**Результат:** Функция завершения спец-задания теперь работает корректно во всех сценариях, включая случаи когда нет данных в `frozen_tasks_info`.

---

## Исправление работы таймеров при спец-заданиях

**Проблема:** При назначении спец-задания текущее задание замораживалось корректно, но после завершения спец-задания таймер восстановленного задания запускался заново вместо продолжения с сохраненного времени.

**Корневая причина:** В файле `special_task_completion.py` при восстановлении таймера использовался параметр `allocated_seconds` (полное выделенное время) вместо `total_seconds` (оставшееся время из `frozen_tasks_info`).

**Исправления:**
1. ✅ **special_task_completion.py (строка 173)** - изменено передача параметра в `update_timer()` с `allocated_seconds` на `total_seconds`, который содержит корректное оставшееся время
2. ✅ **auto_special_task_handler.py (строка 112)** - добавлено сохранение `original_start_time` в `frozen_tasks_info` для корректного восстановления времени начала задания
3. ✅ **task_scheduler.py (строки 278-326)** - добавлено сохранение `original_start_time` при заморозке заданий в планировщике

**Результат:** Теперь таймер корректно продолжается с момента заморозки, а не запускается заново. Время начала задания (`time_begin`) также сохраняется правильно.

---

## Исправление множественного назначения спец-заданий одному ОПВ

**Проблема 1:** Планировщик мог назначить несколько спец-заданий одному и тому же ОПВ в одной итерации.

**Корневая причина:** Планировщик не отслеживал, каким ОПВ уже назначил задания в текущей итерации, и при обработке второго задания снова находил того же ОПВ как "свободного".

**Проблема 2 (КРИТИЧЕСКАЯ):** Планировщик назначал спец-задания каждую минуту одному ОПВ, даже если у него уже есть активное спец-задание (приоритет 111).

**Пример из логов:**
```
11:25 → ID 64405 "Поиск товара" → Бексултан Кобетай ✅
11:26 → ID 64406 "Поиск товара" → Бексултан Кобетай ❌ (уже есть 64405!)
11:27 → ID 64407 "Поиск товара" → Бексултан Кобетай ❌ (уже есть 64405!)
```

**Корневая причина проблемы 2:** SQL-запрос проверял только `st.is_constant_task = false`, но не проверял `st.priority = '111'`. Одного условия недостаточно - спец-задания определяются по **обоим** признакам: `is_constant_task = false` AND `priority = '111'`.

**Исправления:**
1. ✅ **task_scheduler.py (строка 117)** - добавлена переменная `assigned_opv_ids = set()` для отслеживания назначенных ОПВ в одной итерации
2. ✅ **task_scheduler.py (строки 158-161)** - добавлен фильтр `assigned_opv_filter` для исключения уже назначенных ОПВ из SQL-запроса
3. ✅ **task_scheduler.py (строка 477)** - после назначения задания ОПВ добавляется в `assigned_opv_ids`
4. ✅ **task_scheduler.py (строка 179)** - КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ: добавлено условие `st.priority = '111'` вместе с существующим `st.is_constant_task = false` для точной идентификации спец-заданий

**Результат:** Теперь ОПВ не получит новое спец-задание, если у него уже есть активное спец-задание (is_constant_task = false AND priority = '111').

---

## Исправление "прыжков" таймера при восстановлении

**Проблема:** После завершения спец-задания таймер восстановленного задания "прыгал" с правильного времени (12:30) обратно на начальное (14:45), теряя накопленное время работы.

**Пример из логов:**
```
remaining_before=12:30 -> 12:15  ✅ Работает правильно
freeze_time обновлён: 00:02:45   ✅ Сохранено
Восстановление: elapsed=22s      ❌ Должно быть 165s (2:45)
remaining_before=14:45            ❌ Прыжок назад
```

**Корневая причина:** Функция `get_task_remaining_time()` использовала только данные из памяти (`frozen_tasks_info`), но не читала актуальный `freeze_time` из БД. При перезапуске бота или между спец-заданиями данные в памяти терялись или устаревали.

**Исправление:**
- ✅ **task_utils.py (строки 324-353)** - добавлено чтение `freeze_time` из БД если данных нет в памяти
- ✅ Добавлен парсинг `freeze_time` в разных форматах (строка HH:MM:SS, timedelta, time объект)
- ✅ Теперь функция сначала проверяет память, затем БД

**Результат:** Таймер корректно продолжается с сохраненного времени даже после перезапуска бота или между спец-заданиями.
